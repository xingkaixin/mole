# Mole 功能链路说明文档

## 概述

Mole 是一个基于 Wails 框架的数据库表分析工具，采用 Go 后端 + React 前端的架构。核心功能包括数据库连接管理、元数据字典管理、任务管理、并发分析执行和结果展示。本文档详细说明各个功能模块的执行链路和数据流向。

## 核心功能链路

### 1. 应用启动与初始化链路

#### 1.1 应用启动链路

```
应用启动流程:
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  Wails 启动      │───▶│  后端初始化      │───▶│  前端渲染        │
│  main.go        │    │  App.Startup     │    │  App.tsx        │
└─────────────────┘    └──────────────────┘    └─────────────────┘
        │                        │                        │
        ▼                        ▼                        ▼
   创建嵌入资源          初始化核心组件         加载保存的连接
   Embed Assets          Init Components       Load Connections
        │                        │                        │
        └─────────── 应用就绪 ────────────┘
                    │
                    ▼
               显示欢迎页面
               Welcome Page
```

**启动序列** (`main.go:18`):
```go
func main() {
    // 创建应用实例
    app := backend.NewApp()

    // 启动 Wails 应用
    err := wails.Run(&options.App{
        Title:  "Mole",
        Width:  1024,
        Height: 768,
        OnStartup: app.Startup,
        Bind: []interface{}{app},
    })
}
```

**后端初始化** (`app.go:34`):
```go
func (a *App) Startup(ctx context.Context) {
    a.ctx = ctx

    // 初始化日志系统
    err := InitLogger(ctx)

    // 初始化存储管理器
    storageManager, err := NewStorageManager()
    a.storageManager = storageManager

    // 初始化任务管理器
    a.taskManager = NewTaskManager(5, a.analysisEngine, a.dbManager, a.storageManager)
    a.taskManager.Start()
}
```

### 2. 数据库连接管理链路

#### 2.1 新增数据库连接链路

```
用户操作流程:
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  配置页面       │───▶│  连接测试        │───▶│  保存配置        │
│  ConfigPage     │    │  TestConnection  │    │  SaveConnection │
└─────────────────┘    └──────────────────┘    └─────────────────┘
        │                        │                        │
        ▼                        ▼                        ▼
   用户填写配置             验证连接可用性          持久化到SQLite
   Form Validation          MySQL Ping             Storage Manager
        │                        │                        │
        └─────────── 成功 ────────┴─────────── 成功 ────────┘
                    │                        │
                    ▼                        ▼
               显示成功提示              更新连接列表
               Toast Success            State Update
```

**详细步骤**:

1. **用户配置阶段** (`ConfigPage.tsx`)
   ```typescript
   // 用户填写数据库配置
   const [dbConfig, setDbConfig] = useState<DatabaseConfig>({
       name: "", host: "localhost", port: 3306,
       username: "root", password: "", database: ""
   });
   ```

2. **连接测试阶段** (`app.go:48`)
   ```go
   func (a *App) TestDatabaseConnection(config DatabaseConfig) (string, error) {
       err := a.dbManager.TestConnection(&config)
       if err != nil {
           return "", fmt.Errorf("连接失败: %s", err.Error())
       }
       return "连接成功", nil
   }
   ```

3. **保存配置阶段** (`storage.go:139`)
   ```go
   func (sm *StorageManager) SaveConnection(config DatabaseConfig) error {
       query := `INSERT OR REPLACE INTO database_connections ...`
       _, err := sm.db.Exec(query, config.ID, config.Name, ...)
       return err
   }
   ```

#### 1.2 连接已有数据库链路

```
用户操作流程:
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  选择连接        │───▶│  建立连接        │───▶│  获取表列表      │
│  WelcomePage    │    │  ConnectDatabase │    │  GetTables      │
└─────────────────┘    └──────────────────┘    └─────────────────┘
        │                        │                        │
        ▼                        ▼                        ▼
   从存储加载配置          建立MySQL连接         查询SHOW TABLES
   SQLite Query          Database Manager     Database Query
        │                        │                        │
        └─────────── 成功 ────────┴─────────── 成功 ────────┘
                    │                        │
                    ▼                        ▼
               跳转表选择页            显示表列表
               Navigate Tables       Update Table State
```

**关键代码路径**:

1. **连接建立** (`database.go:34`)
   ```go
   func (dm *DatabaseManager) Connect(config *DatabaseConfig) error {
       dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s",
           config.Username, config.Password, config.Host, config.Port, config.Database)
       db, err := sql.Open("mysql", dsn)
       // ... 连接验证和设置
   }
   ```

2. **表列表获取** (`database.go:80`)
   ```go
   func (dm *DatabaseManager) GetTables() ([]string, error) {
       rows, err := dm.db.Query("SHOW TABLES")
       // ... 处理结果
   }
   ```

### 3. 元数据字典管理链路

#### 3.1 字典更新链路

```
字典更新流程:
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  触发更新        │───▶│  批量查询元数据   │───▶│  持久化存储      │
│  UpdateMetadata │    │  Query Metadata  │    │  Persist Data   │
└─────────────────┘    └──────────────────┘    └─────────────────┘
        │                        │                        │
        ▼                        ▼                        ▼
   临时连接数据库            查询所有表结构         保存到元数据表
   Temp DB Connection       Schema Query         Metadata Tables
        │                        │                        │
        └─────────── 元数据收集完成 ────────────┘
                    │
                    ▼
               更新UI显示
               Update UI
```

**字典更新实现** (`app.go:352`):
```go
func (a *App) UpdateDatabaseMetadata(connectionID string) (map[string]interface{}, error) {
    // 获取数据库连接配置
    connections, err := a.storageManager.GetConnections()

    // 创建临时数据库管理器连接
    tempDBManager := NewDatabaseManager()
    err = tempDBManager.Connect(targetConfig)
    defer tempDBManager.Close()

    // 获取所有表的元数据
    allMetadata, err := tempDBManager.GetAllTablesMetadata()

    // 更新存储中的元数据
    err = a.storageManager.UpdateDatabaseMetadata(connectionID, tables)
}
```

#### 3.2 元数据查询链路

```
元数据查询流程:
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  请求元数据      │───▶│  SQLite查询       │───▶│  格式化返回      │
│  Request Meta   │    │  Query SQLite    │    │  Format Return  │
└─────────────────┘    └──────────────────┘    └─────────────────┘
        │                        │                        │
        ▼                        ▼                        ▼
   前端调用接口            查询元数据表         构建JSON响应
   Frontend API Call      Metadata Query      JSON Response
        │                        │                        │
        └─────────── 返回结构化数据 ────────────┘
                    │
                    ▼
               UI渲染显示
               UI Rendering
```

### 4. 任务管理链路

#### 4.1 任务创建与管理链路

```
任务管理流程:
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  创建任务        │───▶│  添加表到任务     │───▶│  任务管理        │
│  CreateTask     │    │  AddTablesTask   │    │  TaskManage     │
└─────────────────┘    └──────────────────┘    └─────────────────┘
        │                        │                        │
        ▼                        ▼                        ▼
   生成任务ID             关联表与任务         显示任务列表
   Generate Task ID       Relate Tables        Show Task List
        │                        │                        │
        └─────────── 任务体系建立 ────────────┘
                    │
                    ▼
               支持分析启动
               Ready for Analysis
```

**任务管理实现** (`app.go:498`):
```go
func (a *App) CreateTask(name, description string) (map[string]interface{}, error) {
    task := &TaskInfo{
        ID:          uuid.New().String(),
        Name:        name,
        Description: description,
        Status:      "active",
    }

    err := a.storageManager.SaveTask(task)
}
```

#### 4.2 任务表关联管理链路

```
任务表关联流程:
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  选择表          │───▶│  添加到任务      │───▶│  状态管理        │
│  SelectTables   │    │  AddToTask       │    │  StatusManage   │
└─────────────────┘    └──────────────────┘    └─────────────────┘
        │                        │                        │
        ▼                        ▼                        ▼
   从元数据选表            创建关联记录         设置初始状态
   Select from Metadata   Create Relation      Set Initial Status
        │                        │                        │
        └─────────── 关联建立完成 ────────────┘
                    │
                    ▼
               可进行分析操作
               Ready for Analysis
```

### 5. 表选择和分析链路

#### 5.1 表选择管理链路

```
表选择流程:
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  显示表列表      │───▶│  用户选择表      │───▶│  保存选择状态    │
│  TablesPage     │    │  ToggleSelection │    │  SaveSelections │
└─────────────────┘    └──────────────────┘    └─────────────────┘
        │                        │                        │
        ▼                        ▼                        ▼
   加载已保存选择          更新选中状态          持久化到SQLite
   Load Selections        State Update          Storage Manager
        │                        │                        │
        └─────────────── 实时保存 ─────────┘
                    │
                    ▼
               更新界面显示
               UI Refresh
```

**状态管理** (`App.tsx:204`):
```typescript
const toggleTableSelection = async (table: string) => {
    const newSelectedTables = selectedTables.includes(table)
        ? selectedTables.filter((t) => t !== table)
        : [...selectedTables, table];

    setSelectedTables(newSelectedTables);

    // 实时保存到后端
    try {
        await SaveTableSelections(newSelectedTables);
    } catch (error) {
        console.warn("Failed to save table selections:", error);
    }
};
```

#### 2.2 表元数据加载链路

```
元数据加载流程:
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  触发加载        │───▶│  并行查询元数据   │───▶│  聚合结果        │
│  LoadMetadata   │    │  GetTableMetadata │    │  Result Merge   │
└─────────────────┘    └──────────────────┘    └─────────────────┘
        │                        │                        │
        ▼                        ▼                        ▼
   构建查询计划            MySQL多表查询         整合返回数据
   Query Planning         Parallel Queries     Data Aggregation
        │                        │                        │
        └─────────── 完成并行查询 ────────────┘
                    │
                    ▼
               更新表显示信息
               Update Table Info
```

**元数据查询实现** (`database.go:161`):
```go
func (dm *DatabaseManager) GetTablesMetadata(tableNames []string) (map[string]map[string]interface{}, error) {
    result := make(map[string]map[string]interface{})

    for _, tableName := range tableNames {
        metadata, err := dm.GetTableMetadata(tableName)
        if err != nil {
            result[tableName] = map[string]interface{}{
                "error": err.Error(),
            }
            continue
        }
        result[tableName] = metadata
    }

    return result, nil
}
```

### 6. 分析任务执行链路

#### 6.1 基于任务的分析启动链路

```
任务分析启动流程:
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  启动任务分析    │───▶│  获取待分析表     │───▶│  创建分析任务    │
│  StartTaskAnalysis│ │  GetPendingTables│ │  CreateAnalysisTasks│
└─────────────────┘    └──────────────────┘    └─────────────────┘
        │                        │                        │
        ▼                        ▼                        ▼
   验证任务状态              筛选待分析表         为每表创建并发任务
   Validate Task Status      Filter Pending Tables   Create Concurrent Tasks
        │                        │                        │
        └─────────── 批量任务创建 ────────────┘
                    │
                    ▼
               返回启动结果
               Return Start Result
```

**任务分析启动实现** (`app.go:675`):
```go
func (a *App) StartTaskAnalysis(taskID string) (map[string]interface{}, error) {
    // 获取任务下的所有表
    taskTables, err := a.storageManager.GetTaskTables(taskID)

    // 筛选出状态为"待分析"的表
    var pendingTables []*TaskTableDetail
    for _, table := range taskTables {
        if table.TblStatus == "待分析" {
            pendingTables = append(pendingTables, table)
        }
    }

    // 为每张表创建分析任务
    for _, table := range pendingTables {
        err = a.taskManager.CreateAnalysisTasksForTable(
            taskID, table.ID, table.TableID, table.TableName,
            table.ConnectionID, dbConfig,
        )
    }
}
```

**任务创建逻辑** (`app.go:83`):
```go
func (a *App) StartAnalysisTasks(connectionID string, tables []string) (string, error) {
    // 创建任务组ID
    groupID := fmt.Sprintf("analysis_%s_%d", connectionID, time.Now().Unix())

    // 为每个表创建任务
    for _, tableName := range tables {
        task := &AnalysisTask{
            ID:         fmt.Sprintf("%s_%s", groupID, tableName),
            TableName:  tableName,
            DatabaseID: connectionID,
            Status:     TaskStatusPending,
            Progress:   0,
        }

        err := a.taskManager.AddTask(task)
        // ... 错误处理
    }

    return groupID, nil
}
```

#### 3.2 并发执行链路

```
并发执行流程:
TaskManager
    │
    ▼
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  任务调度器      │───▶│  工作线程池       │───▶│  分析引擎执行    │
│  Scheduler      │    │  Worker Pool     │    │  AnalysisEngine │
└─────────────────┘    └──────────────────┘    └─────────────────┘
        │                        │                        │
        ▼                        ▼                        ▼
   从队列取任务            分配工作线程         执行分析规则
   Dequeue Task           Allocate Worker     Rule Execution
        │                        │                        │
        └─────────── 并发控制 ────────────┘
                    │
                    ▼
               结果持久化
               Save Results
```

**任务取消机制**:
- 每个任务创建独立的context和cancel函数
- 支持用户手动取消和120秒超时自动取消
- context取消会立即中断正在执行的SQL查询
- 任务状态实时更新为"已取消"

**工作池实现** (`task.go:152`):
```go
func (tm *TaskManager) scheduler() {
    for {
        select {
        case <-tm.ctx.Done():
            return
        case task := <-tm.taskQueue:
            // 等待可用的工作线程
            select {
            case <-tm.ctx.Done():
                return
            case <-tm.workers:
                go tm.executeTask(task)  // 启动协程执行任务
            }
        }
    }
}
```

#### 3.3 分析规则执行链路

```
规则执行流程:
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  获取可用规则    │───▶│  逐规则执行      │───▶│  结果聚合        │
│  GetRules       │    │  ExecuteRules    │    │  Aggregate      │
└─────────────────┘    └──────────────────┘    └─────────────────┘
        │                        │                        │
        ▼                        ▼                        ▼
   加载分析规则            MySQL查询执行         整合分析结果
   Load Analysis Rules    Database Queries    Result Processing
        │                        │                        │
        └─────────── 所有规则完成 ────────────┘
                    │
                    ▼
               保存分析结果
               Persist Results
```

**分析引擎执行** (`analysis.go:162`):
```go
func (e *AnalysisEngine) ExecuteAnalysis(db *sql.DB, tableName string, config *DatabaseConfig, ruleNames []string) (map[string]interface{}, error) {
    result := make(map[string]interface{})

    for _, ruleName := range ruleNames {
        rule, exists := e.rules[ruleName]
        if !exists {
            continue
        }

        ruleResult, err := rule.Execute(db, tableName, config)
        if err != nil {
            result[ruleName] = map[string]interface{}{
                "error": err.Error(),
            }
            continue
        }

        result[ruleName] = ruleResult
    }

    return result, nil
}
```

### 4. 实时状态更新链路

#### 4.1 任务进度监控链路

```
进度监控流程:
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  前端轮询查询    │───▶│  获取任务状态    │───▶│  状态更新UI      │
│  Poll Status    │    │  GetTaskStatus   │    │  Update UI      │
└─────────────────┘    └──────────────────┘    └─────────────────┘
        │                        │                        │
        ▼                        ▼                        ▼
   定时查询接口            从内存读取状态         更新进度条和状态
   Interval Query         Memory State         Progress Update
        │                        │                        │
        └─────────── 状态变化 ────────────┘
                    │
                    ▼
               用户界面实时更新
               Real-time UI Update
```

**前端状态监控** (`AnalysisPage.tsx`):
```typescript
const [tasks, setTasks] = useState<Task[]>([]);

useEffect(() => {
    const interval = setInterval(async () => {
        try {
            const taskList = await GetTasksByDatabase(connectionId);
            setTasks(taskList);
        } catch (error) {
            console.error("Failed to get tasks:", error);
        }
    }, 1000); // 每秒查询一次

    return () => clearInterval(interval);
}, [connectionId]);
```

#### 4.2 任务状态流转链路

```
状态流转图:
┌─────────────┐    Start    ┌─────────────┐    Execute    ┌─────────────┐
│   Pending   │ ──────────▶ │   Running   │ ───────────▶ │  Completed  │
│   (待执行)   │            │   (执行中)   │             │  (已完成)   │
└─────────────┘            └─────────────┘             └─────────────┘
       │                           │                           │
       │ Cancel/Timeout/Error      │ Error                      │
       ▼                           ▼                           ▼
┌─────────────┐            ┌─────────────┐             ┌─────────────┐
│  Cancelled  │            │   Failed    │             │   (结束)    │
│  (已取消)   │            │   (失败)    │             │             │
└─────────────┘            └─────────────┘             └─────────────┘

取消触发条件:
1. 用户手动取消 (调用CancelTask接口)
2. 120秒超时自动取消
3. 应用关闭时清理任务
```

**状态管理实现** (`task.go:187`):
```go
func (tm *TaskManager) executeTask(task *AnalysisTask) {
    // 设置为运行状态
    tm.mu.Lock()
    task.Status = TaskStatusRunning
    now := time.Now()
    task.StartedAt = &now
    tm.mu.Unlock()

    // 执行分析
    tm.performTableAnalysis(task)

    // 根据结果更新状态
    tm.mu.Lock()
    if err != nil {
        task.Status = TaskStatusFailed
        task.ErrorMessage = err.Error()
    } else {
        task.Status = TaskStatusCompleted
        task.Progress = 100
    }
    now = time.Now()
    task.CompletedAt = &now
    task.Duration = now.Sub(*task.StartedAt)
    tm.mu.Unlock()
}
```

### 7. 分析结果查看链路

#### 7.1 任务表分析结果查询链路

```
结果查询流程:
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  请求表结果      │───▶│  查询分析结果     │───▶│  格式化返回      │
│  GetTableResult │    │  Query Analysis  │    │  Format Return  │
└─────────────────┘    └──────────────────┘    └─────────────────┘
        │                        │                        │
        ▼                        ▼                        ▼
   任务ID+表ID             关联查询任务表         构建增强响应
   Task+Table ID          Relational Query     Enhanced Response
        │                        │                        │
        └─────────── 返回详细结果 ────────────┘
                    │
                    ▼
               分析详情页面
               Analysis Detail Page
```

**分析结果查询实现** (`app.go:858`):
```go
func (a *App) GetTableAnalysisResult(taskID, taskTableID string) (map[string]interface{}, error) {
    // 获取任务表信息
    taskTables, err := a.storageManager.GetTaskTables(taskID)

    // 找到对应的表
    var targetTable *TaskTableDetail
    for _, table := range taskTables {
        if table.TableID == taskTableID {
            targetTable = table
            break
        }
    }

    // 获取分析结果
    result, err := a.storageManager.GetTaskTableAnalysisResult(taskID, targetTable.TableID)

    // 构建响应
    response := map[string]interface{}{
        "status":         "success",
        "results":        result.Results,
        "connectionName": targetTable.ConnectionName,
        "tableName":      targetTable.TableName,
        "tableComment":   targetTable.TableComment,
        "rowCount":       targetTable.RowCount,
        "tableSize":      targetTable.TableSize,
        "columnCount":    targetTable.ColumnCount,
        "resultId":       result.ID,
    }
}
```

#### 7.2 增强分析结果查询链路

```
增强结果查询流程:
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  请求增强结果    │───▶│  查询完整元数据   │───▶│  构建详细响应    │
│  GetEnhancedResult│ │  Query Full Meta │    │  Build Detail   │
└─────────────────┘    └──────────────────┘    └─────────────────┘
        │                        │                        │
        ▼                        ▼                        ▼
   基础结果ID              包含列信息的完整数据   构建包含列信息的响应
   Base Result ID          Complete Column Info   Build Column Response
        │                        │                        │
        └─────────── 返回完整元数据 ────────────┘
                    │
                    ▼
               详细分析展示
               Detailed Analysis Display
```

**增强分析结果实现** (`app.go:934`):
```go
func (a *App) GetEnhancedAnalysisResult(taskID, taskTableID string) (map[string]interface{}, error) {
    // 获取增强的分析结果
    enhancedResult, err := a.storageManager.GetEnhancedAnalysisResult(result.ID)

    // 构建列信息响应
    columnsResponse := make([]map[string]interface{}, 0)
    for _, column := range enhancedResult.ColumnsInfo {
        columnResponse := map[string]interface{}{
            "name":    column.ColumnName,
            "type":    column.ColumnType,
            "comment": column.ColumnComment,
            "ordinal": column.ColumnOrdinal,
        }
        columnsResponse = append(columnsResponse, columnResponse)
    }

    // 构建响应
    response := map[string]interface{}{
        "status":         "success",
        "results":        enhancedResult.Results,
        "tableName":      enhancedResult.TableName,
        "tableComment":   enhancedResult.TableComment,
        "columns":        columnsResponse,
        "databaseId":     enhancedResult.DatabaseID,
        "analysisStatus": enhancedResult.Status,
        "startedAt":      enhancedResult.StartedAt,
        "completedAt":    enhancedResult.CompletedAt,
        "duration":       enhancedResult.Duration.Seconds(),
        "rules":          enhancedResult.Rules,
    }
}
```

#### 7.3 分析取消链路

```
分析取消流程:
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  用户取消分析    │───▶│  查找执行任务     │───▶│  更新状态        │
│  CancelAnalysis │    │  Find Running    │    │  Update Status  │
└─────────────────┘    └──────────────────┘    └─────────────────┘
        │                        │                        │
        ▼                        ▼                        ▼
   任务ID+表ID             取消正在执行的任务     重置为待分析状态
   Task+Table ID          Cancel Running Task   Reset to Pending
        │                        │                        │
        └─────────── 取消完成 ────────────┘
                    │
                    ▼
               UI状态更新
               UI Status Update
```

**结果查询实现** (`app.go:119`):
```go
func (a *App) GetAnalysisResults(connectionID string) ([]map[string]interface{}, error) {
    var results []*AnalysisResult
    var err error

    if connectionID == "" || connectionID == "all" {
        results, err = a.storageManager.GetAllAnalysisResults()
    } else {
        results, err = a.storageManager.GetAnalysisResults(connectionID)
    }

    // 转换为前端需要的格式
    var formattedResults []map[string]interface{}
    for _, result := range results {
        formattedResults = append(formattedResults, map[string]interface{}{
            "id":           result.ID,
            "databaseId":   result.DatabaseID,
            "tableName":    result.TableName,
            "rules":        result.Rules,
            "results":      result.Results,
            "status":       result.Status,
            "startedAt":    result.StartedAt,
            "completedAt":  result.CompletedAt,
            "duration":     result.Duration.Milliseconds(),
        })
    }

    return formattedResults, nil
}
```

#### 5.2 结果展示链路

```
结果展示组件层次:
ResultsPage
    │
    ├─ AnalysisResultViewer (结果查看器)
    │   │
    │   ├─ Card (结果卡片)
    │   │   │
    │   │   ├─ Badge (状态标签)
    │   │   │
    │   │   ├─ Table (结果表格)
    │   │   │   │
    │   │   │   └─ TableCell (数据单元格)
    │   │   │
    │   │   └─ Progress (进度条)
    │   │
    │   └─ Dialog (详情弹窗)
    │       │
    │       └─ ScrollArea (滚动区域)
    │
    └─ DropdownMenu (操作菜单)
        │
        ├─ Delete (删除操作)
        │
        └─ Export (导出操作)
```

### 6. 错误处理链路

#### 6.1 错误传播链路

```
错误传播流程:
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  底层错误        │───▶│  错误包装        │───▶│  前端错误处理    │
│  Database Error │    │  Error Wrap     │    │  Frontend Error │
└─────────────────┘    └──────────────────┘    └─────────────────┘
        │                        │                        │
        ▼                        ▼                        ▼
   MySQL连接失败         添加上下文信息         用户友好提示
   MySQL Failed         Add Context          User Message
        │                        │                        │
        └─────────── 错误上抛 ────────────┘
                    │
                    ▼
               Toast通知显示
               Toast Notification
```

**分层错误处理**:
```go
// 数据库层错误
func (dm *DatabaseManager) Connect(config *DatabaseConfig) error {
    dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s", ...)
    db, err := sql.Open("mysql", dsn)
    if err != nil {
        return fmt.Errorf("failed to open database: %w", err)
    }
    // ...
}

// 应用层错误包装
func (a *App) ConnectDatabase(config DatabaseConfig) (string, error) {
    err := a.dbManager.Connect(&config)
    if err != nil {
        return "", fmt.Errorf("连接失败: %s", err.Error())
    }
    return "连接成功", nil
}

// 前端错误处理
try {
    await ConnectDatabase(config);
    toast.success("连接成功");
} catch (error) {
    toast.error(error.message);
}
```

### 7. 性能优化链路

#### 7.1 并发控制链路

```
并发控制流程:
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  任务创建        │───▶│  工作池限制       │───▶│  资源释放        │
│  Task Creation  │    │  Worker Limit    │    │  Resource Free  │
└─────────────────┘    └──────────────────┘    └─────────────────┘
        │                        │                        │
        ▼                        ▼                        ▼
   检查工作池状态          信号量控制           释放工作线程
   Check Pool State        Semaphore Control    Release Worker
        │                        │                        │
        └─────────── 执行完成 ────────────┘
                    │
                    ▼
               避免资源耗尽
   防止数据库连接数过多   Prevent DB Overload
```

#### 7.2 数据库连接优化链路

```
连接优化流程:
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  连接池管理      │───▶│  连接复用        │───▶│  连接释放        │
│  Pool Manager   │    │  Connection Reuse│    │  Connection Free│
└─────────────────┘    └──────────────────┘    └─────────────────┘
        │                        │                        │
        ▼                        ▼                        ▼
   检查空闲连接            复用现有连接         定期清理连接
   Check Idle Conn        Reuse Connection    Cleanup Connections
        │                        │                        │
        └─────────── 生命周期管理 ────────────┘
                    │
                    ▼
               提升查询性能
   减少连接建立开销     Reduce Connection Overhead
```

## 总结

Mole 的功能链路设计体现了以下特点：

1. **模块化设计**: 每个功能模块职责明确，接口清晰
2. **异步处理**: 分析任务采用异步并发执行，提升性能
3. **状态管理**: 完善的状态流转和实时更新机制
4. **错误处理**: 分层错误处理，用户友好的错误提示
5. **性能优化**: 连接池、工作池等优化手段确保系统稳定
6. **用户体验**: 实时进度反馈，流畅的交互体验

这些功能链路共同构成了 Mole 应用的核心价值，为用户提供了高效、稳定的数据库表分析体验。