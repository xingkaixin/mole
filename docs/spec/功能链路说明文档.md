# Mole 功能链路说明文档

## 概述

Mole 是一个数据库表分析工具，核心功能是连接目标数据库，选择需要分析的表，然后并发执行分析任务并展示结果。本文档详细说明各个功能模块的执行链路和数据流向。

## 核心功能链路

### 1. 数据库连接管理链路

#### 1.1 新增数据库连接链路

```
用户操作流程:
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  配置页面       │───▶│  连接测试        │───▶│  保存配置        │
│  ConfigPage     │    │  TestConnection  │    │  SaveConnection │
└─────────────────┘    └──────────────────┘    └─────────────────┘
        │                        │                        │
        ▼                        ▼                        ▼
   用户填写配置             验证连接可用性          持久化到SQLite
   Form Validation          MySQL Ping             Storage Manager
        │                        │                        │
        └─────────── 成功 ────────┴─────────── 成功 ────────┘
                    │                        │
                    ▼                        ▼
               显示成功提示              更新连接列表
               Toast Success            State Update
```

**详细步骤**:

1. **用户配置阶段** (`ConfigPage.tsx`)
   ```typescript
   // 用户填写数据库配置
   const [dbConfig, setDbConfig] = useState<DatabaseConfig>({
       name: "", host: "localhost", port: 3306,
       username: "root", password: "", database: ""
   });
   ```

2. **连接测试阶段** (`app.go:48`)
   ```go
   func (a *App) TestDatabaseConnection(config DatabaseConfig) (string, error) {
       err := a.dbManager.TestConnection(&config)
       if err != nil {
           return "", fmt.Errorf("连接失败: %s", err.Error())
       }
       return "连接成功", nil
   }
   ```

3. **保存配置阶段** (`storage.go:139`)
   ```go
   func (sm *StorageManager) SaveConnection(config DatabaseConfig) error {
       query := `INSERT OR REPLACE INTO database_connections ...`
       _, err := sm.db.Exec(query, config.ID, config.Name, ...)
       return err
   }
   ```

#### 1.2 连接已有数据库链路

```
用户操作流程:
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  选择连接        │───▶│  建立连接        │───▶│  获取表列表      │
│  WelcomePage    │    │  ConnectDatabase │    │  GetTables      │
└─────────────────┘    └──────────────────┘    └─────────────────┘
        │                        │                        │
        ▼                        ▼                        ▼
   从存储加载配置          建立MySQL连接         查询SHOW TABLES
   SQLite Query          Database Manager     Database Query
        │                        │                        │
        └─────────── 成功 ────────┴─────────── 成功 ────────┘
                    │                        │
                    ▼                        ▼
               跳转表选择页            显示表列表
               Navigate Tables       Update Table State
```

**关键代码路径**:

1. **连接建立** (`database.go:34`)
   ```go
   func (dm *DatabaseManager) Connect(config *DatabaseConfig) error {
       dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s",
           config.Username, config.Password, config.Host, config.Port, config.Database)
       db, err := sql.Open("mysql", dsn)
       // ... 连接验证和设置
   }
   ```

2. **表列表获取** (`database.go:80`)
   ```go
   func (dm *DatabaseManager) GetTables() ([]string, error) {
       rows, err := dm.db.Query("SHOW TABLES")
       // ... 处理结果
   }
   ```

### 2. 表选择和分析链路

#### 2.1 表选择管理链路

```
表选择流程:
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  显示表列表      │───▶│  用户选择表      │───▶│  保存选择状态    │
│  TablesPage     │    │  ToggleSelection │    │  SaveSelections │
└─────────────────┘    └──────────────────┘    └─────────────────┘
        │                        │                        │
        ▼                        ▼                        ▼
   加载已保存选择          更新选中状态          持久化到SQLite
   Load Selections        State Update          Storage Manager
        │                        │                        │
        └─────────────── 实时保存 ─────────┘
                    │
                    ▼
               更新界面显示
               UI Refresh
```

**状态管理** (`App.tsx:204`):
```typescript
const toggleTableSelection = async (table: string) => {
    const newSelectedTables = selectedTables.includes(table)
        ? selectedTables.filter((t) => t !== table)
        : [...selectedTables, table];

    setSelectedTables(newSelectedTables);

    // 实时保存到后端
    try {
        await SaveTableSelections(newSelectedTables);
    } catch (error) {
        console.warn("Failed to save table selections:", error);
    }
};
```

#### 2.2 表元数据加载链路

```
元数据加载流程:
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  触发加载        │───▶│  并行查询元数据   │───▶│  聚合结果        │
│  LoadMetadata   │    │  GetTableMetadata │    │  Result Merge   │
└─────────────────┘    └──────────────────┘    └─────────────────┘
        │                        │                        │
        ▼                        ▼                        ▼
   构建查询计划            MySQL多表查询         整合返回数据
   Query Planning         Parallel Queries     Data Aggregation
        │                        │                        │
        └─────────── 完成并行查询 ────────────┘
                    │
                    ▼
               更新表显示信息
               Update Table Info
```

**元数据查询实现** (`database.go:161`):
```go
func (dm *DatabaseManager) GetTablesMetadata(tableNames []string) (map[string]map[string]interface{}, error) {
    result := make(map[string]map[string]interface{})

    for _, tableName := range tableNames {
        metadata, err := dm.GetTableMetadata(tableName)
        if err != nil {
            result[tableName] = map[string]interface{}{
                "error": err.Error(),
            }
            continue
        }
        result[tableName] = metadata
    }

    return result, nil
}
```

### 3. 分析任务执行链路

#### 3.1 任务启动链路

```
分析启动流程:
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  用户启动分析    │───▶│  创建分析任务    │───▶│  任务入队        │
│  StartAnalysis  │    │  CreateTasks     │    │  EnqueueTasks   │
└─────────────────┘    └──────────────────┘    └─────────────────┘
        │                        │                        │
        ▼                        ▼                        ▼
   验证选择表              为每个表创建任务      添加到任务队列
   Validate Selection      Task Creation        Task Queue
        │                        │                        │
        └─────────── 任务组创建 ────────────┘
                    │
                    ▼
               返回任务组ID
               Return Group ID
```

**任务创建逻辑** (`app.go:83`):
```go
func (a *App) StartAnalysisTasks(connectionID string, tables []string) (string, error) {
    // 创建任务组ID
    groupID := fmt.Sprintf("analysis_%s_%d", connectionID, time.Now().Unix())

    // 为每个表创建任务
    for _, tableName := range tables {
        task := &AnalysisTask{
            ID:         fmt.Sprintf("%s_%s", groupID, tableName),
            TableName:  tableName,
            DatabaseID: connectionID,
            Status:     TaskStatusPending,
            Progress:   0,
        }

        err := a.taskManager.AddTask(task)
        // ... 错误处理
    }

    return groupID, nil
}
```

#### 3.2 并发执行链路

```
并发执行流程:
TaskManager
    │
    ▼
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  任务调度器      │───▶│  工作线程池       │───▶│  分析引擎执行    │
│  Scheduler      │    │  Worker Pool     │    │  AnalysisEngine │
└─────────────────┘    └──────────────────┘    └─────────────────┘
        │                        │                        │
        ▼                        ▼                        ▼
   从队列取任务            分配工作线程         执行分析规则
   Dequeue Task           Allocate Worker     Rule Execution
        │                        │                        │
        └─────────── 并发控制 ────────────┘
                    │
                    ▼
               结果持久化
               Save Results
```

**工作池实现** (`task.go:152`):
```go
func (tm *TaskManager) scheduler() {
    for {
        select {
        case <-tm.ctx.Done():
            return
        case task := <-tm.taskQueue:
            // 等待可用的工作线程
            select {
            case <-tm.ctx.Done():
                return
            case <-tm.workers:
                go tm.executeTask(task)  // 启动协程执行任务
            }
        }
    }
}
```

#### 3.3 分析规则执行链路

```
规则执行流程:
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  获取可用规则    │───▶│  逐规则执行      │───▶│  结果聚合        │
│  GetRules       │    │  ExecuteRules    │    │  Aggregate      │
└─────────────────┘    └──────────────────┘    └─────────────────┘
        │                        │                        │
        ▼                        ▼                        ▼
   加载分析规则            MySQL查询执行         整合分析结果
   Load Analysis Rules    Database Queries    Result Processing
        │                        │                        │
        └─────────── 所有规则完成 ────────────┘
                    │
                    ▼
               保存分析结果
               Persist Results
```

**分析引擎执行** (`analysis.go:162`):
```go
func (e *AnalysisEngine) ExecuteAnalysis(db *sql.DB, tableName string, config *DatabaseConfig, ruleNames []string) (map[string]interface{}, error) {
    result := make(map[string]interface{})

    for _, ruleName := range ruleNames {
        rule, exists := e.rules[ruleName]
        if !exists {
            continue
        }

        ruleResult, err := rule.Execute(db, tableName, config)
        if err != nil {
            result[ruleName] = map[string]interface{}{
                "error": err.Error(),
            }
            continue
        }

        result[ruleName] = ruleResult
    }

    return result, nil
}
```

### 4. 实时状态更新链路

#### 4.1 任务进度监控链路

```
进度监控流程:
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  前端轮询查询    │───▶│  获取任务状态    │───▶│  状态更新UI      │
│  Poll Status    │    │  GetTaskStatus   │    │  Update UI      │
└─────────────────┘    └──────────────────┘    └─────────────────┘
        │                        │                        │
        ▼                        ▼                        ▼
   定时查询接口            从内存读取状态         更新进度条和状态
   Interval Query         Memory State         Progress Update
        │                        │                        │
        └─────────── 状态变化 ────────────┘
                    │
                    ▼
               用户界面实时更新
               Real-time UI Update
```

**前端状态监控** (`AnalysisPage.tsx`):
```typescript
const [tasks, setTasks] = useState<Task[]>([]);

useEffect(() => {
    const interval = setInterval(async () => {
        try {
            const taskList = await GetTasksByDatabase(connectionId);
            setTasks(taskList);
        } catch (error) {
            console.error("Failed to get tasks:", error);
        }
    }, 1000); // 每秒查询一次

    return () => clearInterval(interval);
}, [connectionId]);
```

#### 4.2 任务状态流转链路

```
状态流转图:
┌─────────────┐    Start    ┌─────────────┐    Execute    ┌─────────────┐
│   Pending   │ ──────────▶ │   Running   │ ───────────▶ │  Completed  │
│   (待执行)   │            │   (执行中)   │             │  (已完成)   │
└─────────────┘            └─────────────┘             └─────────────┘
       │                           │                           │
       │ Cancel/Error              │ Error                      │
       ▼                           ▼                           ▼
┌─────────────┐            ┌─────────────┐             ┌─────────────┐
│  Cancelled  │            │   Failed    │             │   (结束)    │
│  (已取消)   │            │   (失败)    │             │             │
└─────────────┘            └─────────────┘             └─────────────┘
```

**状态管理实现** (`task.go:187`):
```go
func (tm *TaskManager) executeTask(task *AnalysisTask) {
    // 设置为运行状态
    tm.mu.Lock()
    task.Status = TaskStatusRunning
    now := time.Now()
    task.StartedAt = &now
    tm.mu.Unlock()

    // 执行分析
    tm.performTableAnalysis(task)

    // 根据结果更新状态
    tm.mu.Lock()
    if err != nil {
        task.Status = TaskStatusFailed
        task.ErrorMessage = err.Error()
    } else {
        task.Status = TaskStatusCompleted
        task.Progress = 100
    }
    now = time.Now()
    task.CompletedAt = &now
    task.Duration = now.Sub(*task.StartedAt)
    tm.mu.Unlock()
}
```

### 5. 结果展示链路

#### 5.1 分析结果查询链路

```
结果查询流程:
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  请求结果数据    │───▶│  SQLite查询       │───▶│  数据格式化      │
│  Request Data   │    │  Query Results   │    │  Format Data    │
└─────────────────┘    └──────────────────┘    └─────────────────┘
        │                        │                        │
        ▼                        ▼                        ▼
   前端请求接口            查询分析结果表         JSON反序列化
   API Call              SQLite Query          JSON Deserialize
        │                        │                        │
        └─────────── 返回格式化数据 ────────────┘
                    │
                    ▼
               界面渲染展示
               UI Rendering
```

**结果查询实现** (`app.go:119`):
```go
func (a *App) GetAnalysisResults(connectionID string) ([]map[string]interface{}, error) {
    var results []*AnalysisResult
    var err error

    if connectionID == "" || connectionID == "all" {
        results, err = a.storageManager.GetAllAnalysisResults()
    } else {
        results, err = a.storageManager.GetAnalysisResults(connectionID)
    }

    // 转换为前端需要的格式
    var formattedResults []map[string]interface{}
    for _, result := range results {
        formattedResults = append(formattedResults, map[string]interface{}{
            "id":           result.ID,
            "databaseId":   result.DatabaseID,
            "tableName":    result.TableName,
            "rules":        result.Rules,
            "results":      result.Results,
            "status":       result.Status,
            "startedAt":    result.StartedAt,
            "completedAt":  result.CompletedAt,
            "duration":     result.Duration.Milliseconds(),
        })
    }

    return formattedResults, nil
}
```

#### 5.2 结果展示链路

```
结果展示组件层次:
ResultsPage
    │
    ├─ AnalysisResultViewer (结果查看器)
    │   │
    │   ├─ Card (结果卡片)
    │   │   │
    │   │   ├─ Badge (状态标签)
    │   │   │
    │   │   ├─ Table (结果表格)
    │   │   │   │
    │   │   │   └─ TableCell (数据单元格)
    │   │   │
    │   │   └─ Progress (进度条)
    │   │
    │   └─ Dialog (详情弹窗)
    │       │
    │       └─ ScrollArea (滚动区域)
    │
    └─ DropdownMenu (操作菜单)
        │
        ├─ Delete (删除操作)
        │
        └─ Export (导出操作)
```

### 6. 错误处理链路

#### 6.1 错误传播链路

```
错误传播流程:
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  底层错误        │───▶│  错误包装        │───▶│  前端错误处理    │
│  Database Error │    │  Error Wrap     │    │  Frontend Error │
└─────────────────┘    └──────────────────┘    └─────────────────┘
        │                        │                        │
        ▼                        ▼                        ▼
   MySQL连接失败         添加上下文信息         用户友好提示
   MySQL Failed         Add Context          User Message
        │                        │                        │
        └─────────── 错误上抛 ────────────┘
                    │
                    ▼
               Toast通知显示
               Toast Notification
```

**分层错误处理**:
```go
// 数据库层错误
func (dm *DatabaseManager) Connect(config *DatabaseConfig) error {
    dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s", ...)
    db, err := sql.Open("mysql", dsn)
    if err != nil {
        return fmt.Errorf("failed to open database: %w", err)
    }
    // ...
}

// 应用层错误包装
func (a *App) ConnectDatabase(config DatabaseConfig) (string, error) {
    err := a.dbManager.Connect(&config)
    if err != nil {
        return "", fmt.Errorf("连接失败: %s", err.Error())
    }
    return "连接成功", nil
}

// 前端错误处理
try {
    await ConnectDatabase(config);
    toast.success("连接成功");
} catch (error) {
    toast.error(error.message);
}
```

### 7. 性能优化链路

#### 7.1 并发控制链路

```
并发控制流程:
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  任务创建        │───▶│  工作池限制       │───▶│  资源释放        │
│  Task Creation  │    │  Worker Limit    │    │  Resource Free  │
└─────────────────┘    └──────────────────┘    └─────────────────┘
        │                        │                        │
        ▼                        ▼                        ▼
   检查工作池状态          信号量控制           释放工作线程
   Check Pool State        Semaphore Control    Release Worker
        │                        │                        │
        └─────────── 执行完成 ────────────┘
                    │
                    ▼
               避免资源耗尽
   防止数据库连接数过多   Prevent DB Overload
```

#### 7.2 数据库连接优化链路

```
连接优化流程:
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  连接池管理      │───▶│  连接复用        │───▶│  连接释放        │
│  Pool Manager   │    │  Connection Reuse│    │  Connection Free│
└─────────────────┘    └──────────────────┘    └─────────────────┘
        │                        │                        │
        ▼                        ▼                        ▼
   检查空闲连接            复用现有连接         定期清理连接
   Check Idle Conn        Reuse Connection    Cleanup Connections
        │                        │                        │
        └─────────── 生命周期管理 ────────────┘
                    │
                    ▼
               提升查询性能
   减少连接建立开销     Reduce Connection Overhead
```

## 总结

Mole 的功能链路设计体现了以下特点：

1. **模块化设计**: 每个功能模块职责明确，接口清晰
2. **异步处理**: 分析任务采用异步并发执行，提升性能
3. **状态管理**: 完善的状态流转和实时更新机制
4. **错误处理**: 分层错误处理，用户友好的错误提示
5. **性能优化**: 连接池、工作池等优化手段确保系统稳定
6. **用户体验**: 实时进度反馈，流畅的交互体验

这些功能链路共同构成了 Mole 应用的核心价值，为用户提供了高效、稳定的数据库表分析体验。