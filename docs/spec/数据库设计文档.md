# Mole 数据库设计文档

## 数据库架构概览

Mole 系统采用双数据库架构设计：
1. **外部数据库**: 用户配置的目标数据库（如 MySQL），用于分析操作
2. **内部数据库**: SQLite 本地数据库，用于存储应用配置和分析结果

## 内部数据库设计 (SQLite)

### 数据库位置
- **Windows**: `%APPDATA%\Mole\mole.db`
- **macOS**: `~/Library/Application Support/Mole/mole.db`
- **Linux**: `~/.local/share/mole/mole.db`

### 表结构设计

#### 1. database_connections 表
**用途**: 存储数据库连接配置信息

```sql
CREATE TABLE database_connections (
    id TEXT PRIMARY KEY,                    -- 连接唯一标识
    name TEXT NOT NULL,                     -- 连接名称 (用户友好显示)
    type TEXT NOT NULL,                     -- 数据库类型 (mysql, postgresql等)
    host TEXT NOT NULL,                     -- 数据库主机地址
    port INTEGER NOT NULL,                  -- 数据库端口号
    username TEXT NOT NULL,                 -- 数据库用户名
    password TEXT NOT NULL,                 -- 数据库密码 (存储时需要考虑加密)
    database TEXT NOT NULL,                 -- 数据库名称
    concurrency INTEGER DEFAULT 5,          -- 并发度配置
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,  -- 创建时间
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP   -- 更新时间
);
```

**字段说明**:
- `id`: 唯一标识符，通常使用时间戳生成
- `type`: 当前支持 "mysql"，预留扩展其他数据库类型
- `concurrency`: 控制分析任务的并发数，默认值为 5
- `password`: 敏感信息，生产环境建议加密存储

**索引设计**:
```sql
CREATE INDEX idx_database_connections_name ON database_connections(name);
CREATE INDEX idx_database_connections_type ON database_connections(type);
```

#### 2. table_selections 表
**用途**: 存储用户选择的表信息，支持持久化表选择状态

```sql
CREATE TABLE table_selections (
    id INTEGER PRIMARY KEY AUTOINCREMENT,   -- 自增主键
    connection_id TEXT NOT NULL,            -- 关联的数据库连接ID
    table_name TEXT NOT NULL,               -- 表名
    selected BOOLEAN NOT NULL DEFAULT 0,    -- 是否选中 (0: 未选中, 1: 选中)
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,  -- 创建时间
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,  -- 更新时间
    UNIQUE(connection_id, table_name),      -- 联合唯一约束
    FOREIGN KEY (connection_id) REFERENCES database_connections(id) ON DELETE CASCADE
);
```

**约束说明**:
- `UNIQUE(connection_id, table_name)`: 确保同一连接下的表名唯一
- `FOREIGN KEY`: 外键约束，级联删除
- `selected`: 使用布尔类型，SQLite 中存储为 INTEGER (0/1)

**索引设计**:
```sql
CREATE INDEX idx_table_selections_connection_id ON table_selections(connection_id);
CREATE INDEX idx_table_selections_selected ON table_selections(selected);
```

#### 3. analysis_results 表
**用途**: 存储分析任务的执行结果

```sql
CREATE TABLE analysis_results (
    id TEXT PRIMARY KEY,                    -- 分析结果唯一标识
    task_id TEXT NOT NULL,                  -- 关联的任务ID
    table_id TEXT NOT NULL,                 -- 关联的表ID
    table_name TEXT NOT NULL,               -- 被分析的表名
    rules TEXT NOT NULL,                    -- 应用的分析规则 (JSON格式)
    results TEXT NOT NULL,                  -- 分析结果数据 (JSON格式)
    status TEXT NOT NULL,                   -- 分析状态
    started_at DATETIME NOT NULL,           -- 开始时间
    completed_at DATETIME,                  -- 完成时间 (可为空)
    duration INTEGER,                       -- 执行时长 (毫秒)
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,  -- 创建时间
    UNIQUE(task_id, table_id),              -- 任务与表的联合唯一约束
    FOREIGN KEY (task_id) REFERENCES tasks_info(id) ON DELETE CASCADE
);
```

**字段详细说明**:
- `id`: 分析结果唯一标识符
- `task_id`: 关联的任务ID，外键指向tasks_info表
- `table_id`: 关联的表ID，用于精确关联
- `table_name`: 被分析的表名
- `rules`: JSON 数组，存储使用的分析规则列表
  ```json
  ["row_count", "non_null_rate"]
  ```
- `results`: JSON 对象，存储具体的分析结果数据
  ```json
  {
    "row_count": 1000,
    "non_null_rate": {
      "id": 1.0,
      "name": 0.95,
      "email": 0.87
    }
  }
  ```
- `status`: 枚举值 (pending, running, completed, failed, cancelled)
- `duration`: 执行时长，单位为毫秒

**索引设计**:
```sql
CREATE INDEX idx_analysis_results_task_id ON analysis_results(task_id);
CREATE INDEX idx_analysis_results_table_name ON analysis_results(table_name);
CREATE INDEX idx_analysis_results_status ON analysis_results(status);
CREATE INDEX idx_analysis_results_started_at ON analysis_results(started_at);
```

#### 4. metadata_tables 表
**用途**: 存储数据库字典的表元数据信息

```sql
CREATE TABLE metadata_tables (
    id TEXT PRIMARY KEY,                    -- 表唯一标识
    connection_id TEXT NOT NULL,            -- 关联的数据库连接ID
    table_name TEXT NOT NULL,               -- 表名
    table_comment TEXT,                     -- 表注释
    table_size INTEGER DEFAULT 0,           -- 表数据大小(字节)
    row_count INTEGER DEFAULT 0,            -- 表行数
    column_count INTEGER DEFAULT 0,         -- 表列数
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,  -- 创建时间
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,  -- 更新时间
    UNIQUE(connection_id, table_name),      -- 联合唯一约束
    FOREIGN KEY (connection_id) REFERENCES database_connections(id) ON DELETE CASCADE
);
```

**字段说明**:
- `id`: 表的唯一标识符
- `connection_id`: 关联的数据库连接ID
- `table_name`: 数据库中的实际表名
- `table_comment`: 表的注释信息
- `table_size`: 表的数据大小，单位字节
- `row_count`: 表的行数统计
- `column_count`: 表的列数统计

**索引设计**:
```sql
CREATE INDEX idx_metadata_tables_connection_id ON metadata_tables(connection_id);
CREATE INDEX idx_metadata_tables_table_name ON metadata_tables(table_name);
CREATE INDEX idx_metadata_tables_row_count ON metadata_tables(row_count);
```

#### 5. metadata_columns 表
**用途**: 存储数据库字典的列元数据信息

```sql
CREATE TABLE metadata_columns (
    id TEXT PRIMARY KEY,                    -- 列唯一标识
    table_id TEXT NOT NULL,                 -- 关联的表ID
    column_name TEXT NOT NULL,              -- 列名
    column_comment TEXT,                    -- 列注释
    column_ordinal INTEGER NOT NULL,        -- 列序号(从0开始)
    column_type TEXT,                       -- 列数据类型
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,  -- 创建时间
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,  -- 更新时间
    UNIQUE(table_id, column_name),          -- 表与列名的联合唯一约束
    FOREIGN KEY (table_id) REFERENCES metadata_tables(id) ON DELETE CASCADE
);
```

**字段说明**:
- `id`: 列的唯一标识符
- `table_id`: 关联的表ID，外键指向metadata_tables表
- `column_name`: 列的实际名称
- `column_comment`: 列的注释信息
- `column_ordinal`: 列在表中的位置序号，从0开始
- `column_type`: 列的数据类型

**索引设计**:
```sql
CREATE INDEX idx_metadata_columns_table_id ON metadata_columns(table_id);
CREATE INDEX idx_metadata_columns_column_name ON metadata_columns(column_name);
CREATE INDEX idx_metadata_columns_ordinal ON metadata_columns(column_ordinal);
```

#### 6. tasks_info 表
**用途**: 存储分析任务的基本信息

```sql
CREATE TABLE tasks_info (
    id TEXT PRIMARY KEY,                    -- 任务唯一标识
    name TEXT NOT NULL,                     -- 任务名称
    description TEXT,                       -- 任务描述
    status TEXT NOT NULL DEFAULT 'active', -- 任务状态
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,  -- 创建时间
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP   -- 更新时间
);
```

**字段说明**:
- `id`: 任务唯一标识符
- `name`: 任务的显示名称
- `description`: 任务的详细描述
- `status`: 任务状态 (active, archived, deleted)

**索引设计**:
```sql
CREATE INDEX idx_tasks_info_status ON tasks_info(status);
CREATE INDEX idx_tasks_info_name ON tasks_info(name);
CREATE INDEX idx_tasks_info_created_at ON tasks_info(created_at);
```

#### 7. tasks_tbls 表
**用途**: 存储任务与表的关联关系

```sql
CREATE TABLE tasks_tbls (
    id TEXT PRIMARY KEY,                    -- 任务表关联唯一标识
    task_id TEXT NOT NULL,                  -- 关联的任务ID
    table_id TEXT NOT NULL,                 -- 关联的表ID
    tbl_status TEXT NOT NULL DEFAULT '待分析', -- 表状态
    added_at DATETIME DEFAULT CURRENT_TIMESTAMP, -- 添加时间
    FOREIGN KEY (task_id) REFERENCES tasks_info(id) ON DELETE CASCADE
);
```

**字段说明**:
- `id`: 任务表关联的唯一标识符
- `task_id`: 关联的任务ID，外键指向tasks_info表
- `table_id`: 关联的表ID，对应metadata_tables表的id
- `tbl_status`: 表的分析状态 (待分析, 分析中, 分析完成, 分析失败)
- `added_at`: 表添加到任务的时间

**表状态枚举**:
- `待分析`: 表已添加到任务，但尚未开始分析
- `分析中`: 表正在进行分析
- `分析完成`: 表分析已完成，结果可用
- `分析失败`: 表分析过程中发生错误

**索引设计**:
```sql
CREATE INDEX idx_tasks_tbls_task_id ON tasks_tbls(task_id);
CREATE INDEX idx_tasks_tbls_table_id ON tasks_tbls(table_id);
CREATE INDEX idx_tasks_tbls_status ON tasks_tbls(tbl_status);
CREATE INDEX idx_tasks_tbls_added_at ON tasks_tbls(added_at);
```

### 数据关系图

```
database_connections (1) -----> (N) table_selections
                     |
                     +-----> (N) metadata_tables (1) -----> (N) metadata_columns
                     |                              |
                     +-----> (N) analysis_results <---- (N) tasks_info (1) -----> (N) tasks_tbls (N) -----> (N) metadata_tables
```

**关系说明**:
- `database_connections` 是核心表，与其他所有业务表都有关联
- `metadata_tables` 和 `metadata_columns` 构成数据库字典体系
- `tasks_info` 和 `tasks_tbls` 构成任务管理体系
- `analysis_results` 同时关联任务和表，记录分析结果

### 完整的表创建语句

```sql
-- 创建数据库连接配置表
CREATE TABLE IF NOT EXISTS database_connections (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    type TEXT NOT NULL,
    host TEXT NOT NULL,
    port INTEGER NOT NULL,
    username TEXT NOT NULL,
    password TEXT NOT NULL,
    database TEXT NOT NULL,
    concurrency INTEGER DEFAULT 5,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 创建表选择状态表
CREATE TABLE IF NOT EXISTS table_selections (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    connection_id TEXT NOT NULL,
    table_name TEXT NOT NULL,
    selected BOOLEAN NOT NULL DEFAULT 0,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(connection_id, table_name),
    FOREIGN KEY (connection_id) REFERENCES database_connections(id) ON DELETE CASCADE
);

-- 创建元数据表
CREATE TABLE IF NOT EXISTS metadata_tables (
    id TEXT PRIMARY KEY,
    connection_id TEXT NOT NULL,
    table_name TEXT NOT NULL,
    table_comment TEXT,
    table_size INTEGER DEFAULT 0,
    row_count INTEGER DEFAULT 0,
    column_count INTEGER DEFAULT 0,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(connection_id, table_name),
    FOREIGN KEY (connection_id) REFERENCES database_connections(id) ON DELETE CASCADE
);

-- 创建元数据列表
CREATE TABLE IF NOT EXISTS metadata_columns (
    id TEXT PRIMARY KEY,
    table_id TEXT NOT NULL,
    column_name TEXT NOT NULL,
    column_comment TEXT,
    column_ordinal INTEGER NOT NULL,
    column_type TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(table_id, column_name),
    FOREIGN KEY (table_id) REFERENCES metadata_tables(id) ON DELETE CASCADE
);

-- 创建任务信息表
CREATE TABLE IF NOT EXISTS tasks_info (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    status TEXT NOT NULL DEFAULT 'active',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 创建任务表关联表
CREATE TABLE IF NOT EXISTS tasks_tbls (
    id TEXT PRIMARY KEY,
    task_id TEXT NOT NULL,
    table_id TEXT NOT NULL,
    tbl_status TEXT NOT NULL DEFAULT '待分析',
    added_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (task_id) REFERENCES tasks_info(id) ON DELETE CASCADE
);

-- 创建分析结果表
CREATE TABLE IF NOT EXISTS analysis_results (
    id TEXT PRIMARY KEY,
    task_id TEXT NOT NULL,
    table_id TEXT NOT NULL,
    table_name TEXT NOT NULL,
    rules TEXT NOT NULL,
    results TEXT NOT NULL,
    status TEXT NOT NULL,
    started_at DATETIME NOT NULL,
    completed_at DATETIME,
    duration INTEGER,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(task_id, table_id),
    FOREIGN KEY (task_id) REFERENCES tasks_info(id) ON DELETE CASCADE
);
```

## 外部数据库交互设计

### 支持的数据库类型
当前主要支持 **MySQL**，设计预留扩展其他数据库类型：

```go
// DatabaseConfig 中的 type 字段支持：
- "mysql"     - MySQL/MariaDB
- "postgresql" - PostgreSQL (预留)
- "sqlite"    - SQLite (预留)
- "oracle"    - Oracle (预留)
```

### MySQL 元数据查询

#### 1. 获取表列表
```sql
SHOW TABLES;
```

#### 2. 获取表结构信息
```sql
SHOW COLUMNS FROM table_name;
```

#### 3. 获取表统计信息
```sql
-- 获取行数
SELECT COUNT(*) FROM table_name;

-- 获取数据大小和索引大小
SELECT
    data_length + index_length as total_size,
    data_length,
    index_length
FROM information_schema.tables
WHERE table_schema = ? AND table_name = ?;

-- 获取表注释
SELECT table_comment
FROM information_schema.tables
WHERE table_schema = ? AND table_name = ?;

-- 获取列信息
SELECT COUNT(*)
FROM information_schema.columns
WHERE table_schema = ? AND table_name = ?;

-- 获取详细列信息(用于元数据字典)
SELECT
    COLUMN_NAME as column_name,
    COLUMN_COMMENT as column_comment,
    ORDINAL_POSITION as column_ordinal,
    DATA_TYPE as column_type
FROM information_schema.columns
WHERE table_schema = ? AND table_name = ?
ORDER BY ORDINAL_POSITION;
```

#### 4. 批量元数据查询优化
```sql
-- 一次查询获取所有表的元数据信息
SELECT
    t.TABLE_NAME,
    t.TABLE_COMMENT,
    t.DATA_LENGTH,
    t.INDEX_LENGTH,
    (SELECT COUNT(*) FROM information_schema.columns c
     WHERE c.TABLE_SCHEMA = t.TABLE_SCHEMA AND c.TABLE_NAME = t.TABLE_NAME) as column_count
FROM information_schema.tables t
WHERE t.TABLE_SCHEMA = ?
ORDER BY t.TABLE_NAME;
```

### 数据库连接池设计

#### 连接池参数
```go
type ConnectionPool struct {
    maxOpenConns    int           // 最大打开连接数
    maxIdleConns    int           // 最大空闲连接数
    connMaxLifetime time.Duration // 连接最大生存时间
    connMaxIdleTime time.Duration // 连接最大空闲时间
}
```

#### 默认配置
```go
maxOpenConns: 10
maxIdleConns: 5
connMaxLifetime: 1 * time.Hour
connMaxIdleTime: 30 * time.Minute
```

## 数据迁移和版本管理

### 版本控制策略
使用 SQLite 的 `PRAGMA user_version` 管理数据库版本：

```sql
-- 检查当前版本
PRAGMA user_version;

-- 设置版本号
PRAGMA user_version = 1;
```

### 迁移脚本示例
```go
func migrateDatabase(db *sql.DB) error {
    var version int
    db.QueryRow("PRAGMA user_version").Scan(&version)

    if version < 1 {
        // 创建初始表结构
        createTables(db)
        db.Exec("PRAGMA user_version = 1")
    }

    if version < 2 {
        // 添加新字段或表
        addNewFields(db)
        db.Exec("PRAGMA user_version = 2")
    }

    return nil
}
```

## 性能优化策略

### 1. 索引优化
- 为常用查询字段创建索引
- 复合索引优化联合查询
- 定期分析索引使用情况

### 2. 查询优化
- 使用预编译语句 (prepared statements)
- 批量操作减少数据库往返
- 合理使用事务
- **MySQL布尔表达式优化**: 利用 `AVG(column IS NULL)` 计算空置率
  - 非空值率分析从 2N+1 次查询优化为 1 次查询
  - 核心SQL: `SELECT 1-AVG(col1 IS NULL), 1-AVG(col2 IS NULL), ... FROM table`

### 3. 连接池优化
- 根据并发需求调整连接池大小
- 监控连接池使用情况
- 及时释放空闲连接

### 4. 存储优化
- JSON 数据压缩存储
- 大结果集分页处理
- 历史数据定期清理

## 数据备份和恢复

### 备份策略
```bash
# SQLite 备份
sqlite3 mole.db ".backup mole_backup_$(date +%Y%m%d_%H%M%S).db"

# 增量备份 (通过 WAL 模式)
PRAGMA journal_mode = WAL;
```

### 恢复策略
```bash
# 恢复备份
sqlite3 mole.db ".restore mole_backup_20240101_120000.db"
```

## 安全考虑

### 1. 敏感数据保护
- 数据库密码加密存储
- 使用系统密钥库存储敏感信息
- 内存中密码及时清理

### 2. 访问控制
- 数据库文件权限控制
- 应用程序权限最小化
- 审计日志记录

### 3. SQL 注入防护
- 使用参数化查询
- 输入验证和清理
- 错误信息脱敏

## 监控和维护

### 1. 性能监控
```sql
-- 查看表统计信息
SELECT
    name,
    sql,
    COUNT(*) as usage_count
FROM sqlite_master
WHERE type = 'index'
GROUP BY name, sql;
```

### 2. 存储监控
```sql
-- 查看数据库文件大小
.database

-- 查看表大小
SELECT
    name,
    COUNT(*) as row_count
FROM sqlite_master
WHERE type = 'table';
```

### 3. 定期维护
```sql
-- 清理数据库
VACUUM;

-- 重建索引
REINDEX;

-- 分析统计信息
ANALYZE;
```

## 任务管理数据流

### 任务生命周期数据模型

任务的状态变化通过数据库表之间的关联来追踪：

```sql
-- 任务状态查询示例
SELECT
    t.id,
    t.name,
    t.status as task_status,
    COUNT(tt.id) as table_count,
    COUNT(CASE WHEN tt.tbl_status = '待分析' THEN 1 END) as pending_count,
    COUNT(CASE WHEN tt.tbl_status = '分析中' THEN 1 END) as running_count,
    COUNT(CASE WHEN tt.tbl_status = '分析完成' THEN 1 END) as completed_count,
    COUNT(CASE WHEN tt.tbl_status = '分析失败' THEN 1 END) as failed_count
FROM tasks_info t
LEFT JOIN tasks_tbls tt ON t.id = tt.task_id
WHERE t.status = 'active'
GROUP BY t.id, t.name, t.status;
```

### 数据操作模式

#### 1. 任务创建流程
```sql
-- 步骤1: 创建任务
INSERT INTO tasks_info (id, name, description, status, created_at, updated_at)
VALUES (?, ?, ?, 'active', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP);

-- 步骤2: 关联表
INSERT INTO tasks_tbls (id, task_id, table_id, tbl_status, added_at)
VALUES (?, ?, ?, '待分析', CURRENT_TIMESTAMP);
```

#### 2. 元数据更新流程
```sql
-- 清理旧元数据
DELETE FROM metadata_columns WHERE table_id IN (
    SELECT id FROM metadata_tables WHERE connection_id = ?
);
DELETE FROM metadata_tables WHERE connection_id = ?;

-- 插入新元数据
INSERT INTO metadata_tables (id, connection_id, table_name, table_comment, table_size, row_count, column_count)
VALUES (?, ?, ?, ?, ?, ?, ?);

INSERT INTO metadata_columns (id, table_id, column_name, column_comment, column_ordinal, column_type)
VALUES (?, ?, ?, ?, ?, ?);
```

#### 3. 分析结果存储
```sql
-- 记录分析结果
INSERT INTO analysis_results (id, task_id, table_id, table_name, rules, results, status, started_at, created_at)
VALUES (?, ?, ?, ?, ?, ?, 'pending', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP);

-- 更新状态
UPDATE analysis_results
SET status = 'completed', completed_at = CURRENT_TIMESTAMP, duration = ?
WHERE id = ?;

-- 同步更新任务表状态
UPDATE tasks_tbls
SET tbl_status = '分析完成'
WHERE task_id = ? AND table_id = ?;
```

#### 4. 增强分析结果查询
```sql
-- 获取包含列信息的完整分析结果
SELECT
    ar.id,
    ar.table_name,
    ar.results,
    ar.status,
    ar.started_at,
    ar.completed_at,
    ar.duration,
    ar.rules,
    mt.table_comment,
    json_group_array(
        json_object(
            'name', mc.column_name,
            'type', mc.column_type,
            'comment', mc.column_comment,
            'ordinal', mc.column_ordinal
        )
    ) as columns
FROM analysis_results ar
JOIN metadata_tables mt ON ar.table_id = mt.id
LEFT JOIN metadata_columns mc ON mt.id = mc.table_id
WHERE ar.task_id = ? AND ar.table_id = ?
GROUP BY ar.id, ar.table_name, ar.results, ar.status, ar.started_at, ar.completed_at, ar.duration, ar.rules, mt.table_comment;
```

## 扩展性设计

### 1. 新表结构预留
```sql
-- 预留扩展表
CREATE TABLE IF NOT EXISTS analysis_rules (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    config TEXT,  -- JSON配置
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS analysis_schedules (
    id TEXT PRIMARY KEY,
    connection_id TEXT,
    rule_config TEXT,
    schedule_config TEXT,  -- cron表达式等
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

### 2. 水平扩展支持
- 分区表设计 (按时间分区analysis_results表)
- 分片策略预留 (按连接ID分片metadata_tables)
- 分布式存储接口

### 3. 性能优化扩展
- 表分区: analysis_results按started_at时间分区
- 索引优化: 复合索引支持复杂查询
- 缓存策略: 元数据缓存机制预留

### 4. 审计和监控扩展
```sql
-- 预留审计表
CREATE TABLE IF NOT EXISTS audit_logs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    action TEXT NOT NULL,
    table_name TEXT,
    record_id TEXT,
    old_data TEXT,
    new_data TEXT,
    user_id TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

这个数据库设计为 Mole 应用提供了稳定可靠的数据存储基础，支持应用的核心功能需求，并为未来的功能扩展预留了空间。完整的数据关系图和任务生命周期确保了数据的一致性和可追溯性。