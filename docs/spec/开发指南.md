# Mole 开发指南

## 项目概览

Mole 是基于 Wails 框架的桌面应用，用于数据库表的自动化分析。本指南将帮助开发者快速理解项目结构、开发环境搭建以及贡献代码。

## 技术栈

### 后端技术栈
- **Go 1.21+**: 主要后端开发语言
- **Wails v2**: 桌面应用开发框架
- **MySQL Driver**: `github.com/go-sql-driver/mysql`
- **SQLite Driver**: `github.com/mattn/go-sqlite3`

### 前端技术栈
- **React 18**: 用户界面框架
- **TypeScript**: 类型安全
- **Vite**: 构建工具
- **Tailwind CSS**: CSS框架
- **Shadcn UI**: UI组件库
- **Biome**: 代码格式化

## 开发环境搭建

### 前置要求
- Go 1.21+
- Node.js 18+
- Bun (推荐) 或 npm/yarn

### 1. 克隆项目
```bash
git clone <repository-url>
cd mole
```

### 2. 安装依赖
```bash
# 安装前端依赖
make deps

# 或者手动安装
cd frontend && bun install
```

### 3. 开发模式运行
```bash
# 启动开发服务器
make dev

# 或者使用 wails 命令
wails dev
```

## 项目结构

```
mole/
├── backend/                    # Go 后端代码
│   ├── app.go                 # 应用核心控制器
│   ├── analysis.go            # 分析引擎和规则
│   ├── connection_pool.go     # 数据库连接池
│   ├── database.go            # 数据库管理
│   ├── storage.go             # 本地存储管理
│   └── task.go                # 任务管理器
│   └── logger.go              # 日志模块
├── frontend/                   # React 前端代码
│   ├── src/
│   │   ├── components/        # 可复用组件
│   │   │   ├── ui/           # UI基础组件 (Shadcn UI)
│   │   │   │   ├── button.tsx
│   │   │   │   ├── card.tsx
│   │   │   │   ├── dialog.tsx
│   │   │   │   ├── input.tsx
│   │   │   │   ├── label.tsx
│   │   │   │   ├── select.tsx
│   │   │   │   ├── table.tsx
│   │   │   │   └── ...
│   │   │   ├── forms/        # 表单组件
│   │   │   │   ├── DatabaseConfigForm.tsx
│   │   │   │   └── TableSelectionForm.tsx
│   │   │   ├── add-table-dialog.tsx
│   │   │   ├── connection-dialog.tsx
│   │   │   ├── create-task-dialog.tsx
│   │   │   ├── database-card.tsx
│   │   │   ├── execution-logs-dialog.tsx
│   │   │   ├── AnalysisProgress.tsx
│   │   │   ├── AnalysisResultViewer.tsx
│   │   │   ├── ResultsTable.tsx
│   │   │   ├── Sidebar.tsx
│   │   │   ├── mode-toggle.tsx
│   │   │   └── theme-provider.tsx
│   │   ├── pages/            # 页面组件
│   │   │   ├── WelcomePage.tsx
│   │   │   ├── TablesPage.tsx
│   │   │   ├── TaskManagementPage.tsx
│   │   │   ├── TaskProgressPage.tsx
│   │   │   ├── AnalysisPage.tsx
│   │   │   ├── AnalysisTablesPage.tsx
│   │   │   ├── AnalysisReportsPage.tsx
│   │   │   ├── ResultsPage.tsx
│   │   │   └── ConfigPage.tsx
│   │   ├── types/            # TypeScript类型定义
│   │   │   └── index.ts
│   │   ├── lib/              # 工具函数
│   │   │   ├── utils.ts
│   │   │   └── logger.ts     # 前端日志工具
│   │   ├── App.tsx           # 应用主组件
│   │   ├── main.tsx          # 前端入口
│   │   └── global.css        # 全局样式
│   ├── wailsjs/              # Wails 自动生成的绑定代码
│   │   ├── go/backend/       # Go 后端API绑定
│   │   └── runtime/          # Wails 运行时
│   ├── package.json          # 前端依赖配置
│   ├── vite.config.ts        # Vite 构建配置
│   ├── tsconfig.json         # TypeScript 配置
│   ├── biome.json            # 代码格式化和检查配置
│   └── components.json       # Shadcn UI 配置
├── docs/                      # 文档
│   └── spec/                 # 技术规范文档
│       ├── 开发指南.md
│       ├── 技术架构文档.md
│       ├── API接口文档.md
│       ├── 数据库设计文档.md
│       ├── 部署指南.md
│       └── 功能链路说明文档.md
├── tasks/                     # 任务规划
│   ├── 002.md               # 当前迭代任务
│   ├── 002-iteration-plan.md
│   └── done/                # 已完成任务
├── .claude/                   # Claude 配置
├── main.go                    # 应用入口
├── wails.json                 # Wails 应用配置
├── go.mod                     # Go 模块定义
├── go.sum                     # Go 依赖锁定文件
├── Makefile                   # 构建脚本
└── README.md                  # 项目说明
```

## 开发规范

### Go 代码规范

#### 1. 命名规范
```go
// 结构体使用大驼峰
type DatabaseManager struct {
    config *DatabaseConfig
    db     *sql.DB
}

// 函数名使用大驼峰（公开）或小驼峰（私有）
func NewDatabaseManager() *DatabaseManager {
    return &DatabaseManager{}
}

func (dm *DatabaseManager) Connect(config *DatabaseConfig) error {
    // 实现
}

// 常量使用大驼峰
const (
    TaskStatusPending   TaskStatus = "pending"
    TaskStatusRunning   TaskStatus = "running"
    TaskStatusCompleted TaskStatus = "completed"
)
```

#### 2. 错误处理
```go
// 使用 fmt.Errorf 包装错误
if err != nil {
    return "", fmt.Errorf("failed to connect database: %w", err)
}

// 提供上下文信息
if err := db.Ping(); err != nil {
    return "", fmt.Errorf("connection test failed for %s: %w", config.Host, err)
}
```

#### 3. 接口设计
```go
// 接口命名以 -er 结尾
type AnalysisRule interface {
    GetName() string
    GetDescription() string
    Execute(db *sql.DB, tableName string, config *DatabaseConfig) (interface{}, error)
}

// 接口实现
type RowCountRule struct{}

func (r *RowCountRule) GetName() string {
    return "row_count"
}
```

### TypeScript 代码规范

#### 1. 组件定义
```typescript
// 使用函数式组件和 TypeScript 接口
interface DatabaseConfigFormProps {
  config: DatabaseConfig;
  isAdding: boolean;
  onConfigChange: (field: keyof DatabaseConfig, value: string | number) => void;
  onTestConnection: () => void;
  onSaveConnection: () => void;
  onBack: () => void;
  connectionStatus: string;
}

export const DatabaseConfigForm: React.FC<DatabaseConfigFormProps> = ({
  config,
  isAdding,
  onConfigChange,
  onTestConnection,
  onSaveConnection,
  onBack,
  connectionStatus
}) => {
  // 组件实现
};
```

#### 2. 类型定义
```typescript
// 接口定义使用清晰的类型
export interface DatabaseConfig {
  id: string;
  name: string;
  type: string;
  host: string;
  port: number;
  username: string;
  password: string;
  database: string;
  concurrency: number;
}

// 联合类型定义枚举值
export type TaskStatus = "pending" | "running" | "completed" | "failed" | "cancelled";
```

#### 3. 异步处理
```typescript
// 使用 async/await 和错误处理
const handleConnectDatabase = async (config: DatabaseConfig) => {
  try {
    const result = await ConnectDatabase(config);
    toast.success(result);
    setCurrentStep("analysis_tables");
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    toast.error(message);
  }
};
```

## 核心模块开发

### 1. 添加新的分析规则

#### 步骤 1: 实现规则接口
```go
// 在 backend/analysis.go 中添加新规则
type CustomRule struct{}

func (r *CustomRule) GetName() string {
    return "custom_rule"
}

func (r *CustomRule) GetDescription() string {
    return "自定义分析规则"
}

func (r *CustomRule) Execute(db *sql.DB, tableName string, config *DatabaseConfig) (interface{}, error) {
    // 实现分析逻辑
    var result int64
    err := db.QueryRow(fmt.Sprintf("SELECT COUNT(*) FROM %s WHERE condition", tableName)).Scan(&result)
    if err != nil {
        return nil, fmt.Errorf("failed to execute custom rule: %w", err)
    }
    return result, nil
}
```

#### 步骤 2: 注册规则
```go
// 在 NewAnalysisEngine 函数中注册新规则
func NewAnalysisEngine() *AnalysisEngine {
    engine := &AnalysisEngine{
        rules: make(map[string]AnalysisRule),
    }

    // 注册默认规则
    engine.RegisterRule(&RowCountRule{})
    engine.RegisterRule(&NonNullRateRule{})
    engine.RegisterRule(&CustomRule{}) // 添加新规则

    return engine
}
```

### 2. 添加新的数据库支持

#### 步骤 1: 扩展数据库管理器
```go
// 在 backend/database.go 中添加新数据库支持
func (dm *DatabaseManager) Connect(config *DatabaseConfig) error {
    switch config.Type {
    case "mysql":
        return dm.connectMySQL(config)
    case "postgresql":
        return dm.connectPostgreSQL(config)
    default:
        return fmt.Errorf("unsupported database type: %s", config.Type)
    }
}

func (dm *DatabaseManager) connectPostgreSQL(config *DatabaseConfig) error {
    // PostgreSQL 连接逻辑
    dsn := fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=disable",
        config.Host, config.Port, config.Username, config.Password, config.Database)

    db, err := sql.Open("postgres", dsn)
    if err != nil {
        return fmt.Errorf("failed to open postgresql database: %w", err)
    }

    if err := db.Ping(); err != nil {
        db.Close()
        return fmt.Errorf("failed to ping postgresql database: %w", err)
    }

    dm.config = config
    dm.db = db
    return nil
}
```

### 3. 添加新页面组件

#### 步骤 1: 创建页面组件
```typescript
// 在 frontend/src/pages/ 中创建新组件
import { useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";

export const NewFeaturePage: React.FC = () => {
  const [data, setData] = useState<any[]>([]);

  return (
    <div className="p-6">
      <Card>
        <CardHeader>
          <CardTitle>新功能页面</CardTitle>
        </CardHeader>
        <CardContent>
          {/* 页面内容 */}
        </CardContent>
      </Card>
    </div>
  );
};
```

#### 步骤 2: 添加路由
```typescript
// 在 App.tsx 中添加新页面路由
type AppStep = "welcome" | "config" | "analysis_tables" | "new_feature";

// 在组件渲染中添加
{currentStep === "new_feature" && <NewFeaturePage />}
```

## 构建和部署

### 1. 开发构建
```bash
# 开发模式
make dev

# 前端开发服务器
cd frontend && bun run dev
```

### 2. 生产构建
```bash
# 构建 macOS 应用
make build-mac

# 构建 Windows 应用
make build-windows

# 手动构建
wails build
```

### 3. 代码质量检查
```bash
# 格式化代码
make format

# 代码检查
make lint

# 自动修复
make check
```

## 测试指南

### 1. 后端测试
```go
// 创建测试文件 backend/database_test.go
package backend

import (
    "testing"
)

func TestDatabaseManager_Connect(t *testing.T) {
    dm := NewDatabaseManager()
    config := &DatabaseConfig{
        Type:     "mysql",
        Host:     "localhost",
        Port:     3306,
        Username: "test",
        Password: "test",
        Database: "test_db",
    }

    err := dm.Connect(config)
    if err != nil {
        t.Errorf("Expected no error, got %v", err)
    }
}
```

### 2. 前端测试
```typescript
// 创建测试文件 frontend/src/components/__tests__/DatabaseConfigForm.test.tsx
import { render, screen } from '@testing-library/react';
import { DatabaseConfigForm } from '../forms/DatabaseConfigForm';

test('renders database config form', () => {
  const mockProps = {
    config: { /* mock config */ },
    isAdding: true,
    onConfigChange: jest.fn(),
    onTestConnection: jest.fn(),
    onSaveConnection: jest.fn(),
    onBack: jest.fn(),
    connectionStatus: ''
  };

  render(<DatabaseConfigForm {...mockProps} />);

  expect(screen.getByLabelText('连接名称')).toBeInTheDocument();
});
```

## 日志系统指南

### 概述

Mole 应用实现了完整的日志系统，用于记录应用程序运行状态、用户操作和错误信息。日志系统分为后端和前端两部分，统一存储到本地文件中。

### 日志文件位置

日志文件按日期自动轮转，存储位置因操作系统而异：

- **macOS**: `~/Library/Logs/mole/mole_YYYY-MM-DD.log`
- **Windows**: `%APPDATA%\mole\logs\mole_YYYY-MM-DD.log`
- **Linux**: `~/.local/share/mole/logs/mole_YYYY-MM-DD.log`

### 日志格式

统一日志格式：`时间 [级别] 模块: 操作 - 详细信息`

示例：
```
2025-10-05 12:22:45 [INFO] DATABASE: CONNECT - 数据库连接成功 - 生产数据库
2025-10-05 12:22:45 [ERROR] TASK_MANAGER: ADD_TASK - 任务队列已满 - analysis_123_users
```

### 后端日志使用

#### 1. 基本用法

```go
// 获取日志记录器
logger := GetLogger()
logger.SetModuleName("MODULE_NAME")

// 记录不同级别的日志
logger.LogInfo("OPERATION", "操作描述")
logger.LogError("OPERATION", "错误描述")
logger.LogWarn("OPERATION", "警告描述")
logger.LogDebug("OPERATION", "调试信息")
```

#### 2. 便捷函数

```go
// 专用日志记录函数
LogUserAction("MODULE", "action", "详情")
LogSystemEvent("MODULE", "event", "详情")
LogError("MODULE", "operation", "错误信息")
```

#### 3. 后端日志添加规范

**必须添加日志的场景：**

1. **数据库操作**
```go
func (dm *DatabaseManager) Connect(config *DatabaseConfig) error {
    logger := GetLogger()
    logger.SetModuleName("DATABASE")
    logger.LogInfo("CONNECT", fmt.Sprintf("开始连接数据库 %s@%s:%d/%s",
        config.Username, config.Host, config.Port, config.Database))

    // ... 连接逻辑

    if err != nil {
        logger.LogError("CONNECT", fmt.Sprintf("连接失败 - %s", err.Error()))
        return err
    }

    logger.LogInfo("CONNECT", fmt.Sprintf("连接成功 - %s", config.Name))
    return nil
}
```

2. **任务管理**
```go
func (tm *TaskManager) AddTask(task *AnalysisTask) error {
    logger := GetLogger()
    logger.SetModuleName("TASK_MANAGER")

    logger.LogInfo("ADD_TASK", fmt.Sprintf("添加任务 - %s (表: %s)", task.ID, task.TableName))

    // ... 任务添加逻辑

    if err != nil {
        logger.LogError("ADD_TASK", fmt.Sprintf("添加任务失败 - %s: %v", task.ID, err))
        return err
    }

    logger.LogInfo("ADD_TASK", fmt.Sprintf("任务已加入队列 - %s", task.ID))
    return nil
}
```

3. **API 接口入口**
```go
func (a *App) ConnectDatabase(config DatabaseConfig) (string, error) {
    logger := GetLogger()
    logger.SetModuleName("APP")
    logger.LogInfo("CONNECT_DATABASE", fmt.Sprintf("连接数据库 - %s", config.Name))

    // ... 业务逻辑

    if err != nil {
        logger.LogError("CONNECT_DATABASE", fmt.Sprintf("连接失败 - %s: %s", config.Name, err.Error()))
        return "", err
    }

    logger.LogInfo("CONNECT_DATABASE", fmt.Sprintf("连接成功 - %s", config.Name))
    return "连接成功", nil
}
```

### 前端日志使用

#### 1. 基本用法

```typescript
import { createLogger } from "@/lib/logger";

// 创建模块专属日志记录器
const logger = createLogger('ComponentName');

// 记录用户操作
logger.click('按钮名称');
logger.info('操作类型', '详细信息');
logger.error('操作类型', '错误信息');
```

#### 2. 专用方法

```typescript
// 按钮点击
logger.click('保存按钮');

// 表单提交
logger.formSubmit('用户配置', true, '保存用户配置成功');

// 页面导航
logger.navigate('首页', '设置页面');

// 数据库操作
logger.databaseOperation('连接', '生产数据库', true, '连接成功');
```

#### 3. 前端日志添加规范

**必须添加日志的场景：**

1. **用户界面交互**
```typescript
// 按钮点击事件
const handleSave = () => {
    logger.click('保存按钮');
    // ... 保存逻辑
};

// 表单提交
const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    logger.formSubmit('数据库连接', true, `添加连接 - ${formData.name}`);
    // ... 提交逻辑
};
```

2. **页面导航**
```typescript
const navigateToSettings = () => {
    logger.navigate('当前页面', '设置页面');
    setCurrentPage('settings');
};
```

3. **异步操作**
```typescript
const handleUpdateMetadata = async () => {
    logger.info('更新元数据', `开始更新 - ${connection.name}`);

    try {
        const result = await UpdateDatabaseMetadata(connection.id);
        logger.info('元数据更新成功', `${connection.name} - ${result.message}`);
    } catch (error) {
        logger.error('元数据更新失败', `${connection.name} - ${error.message}`);
    }
};
```

### 日志级别指南

- **INFO**: 正常业务流程、状态变更、用户操作
- **WARN**: 潜在问题、性能警告、降级操作
- **ERROR**: 错误情况、异常处理、失败操作
- **DEBUG**: 详细调试信息（开发环境使用）
- **TRACE**: 最详细的跟踪信息（一般不使用）

### 日志内容规范

#### DO (推荐做法)

✅ **包含关键上下文信息**
```go
logger.LogInfo("CONNECT", fmt.Sprintf("连接数据库 - %s@%s:%d/%s",
    user, host, port, database))
```

✅ **记录操作的开始和结束**
```go
logger.LogInfo("ANALYSIS", "开始分析任务")
// ... 分析逻辑
logger.LogInfo("ANALYSIS", "分析任务完成")
```

✅ **错误时包含足够的调试信息**
```go
logger.LogError("QUERY", fmt.Sprintf("查询失败 - 表: %s, SQL: %s, 错误: %s",
    tableName, query, err.Error()))
```

#### DON'T (避免做法)

❌ **记录敏感信息**
```go
// 错误：不要记录密码
logger.LogInfo("CONNECT", fmt.Sprintf("用户: %s, 密码: %s", username, password))

// 正确：脱敏处理
logger.LogInfo("CONNECT", fmt.Sprintf("用户: %s, 密码: ****", username))
```

❌ **过于频繁的日志**
```go
// 错误：在循环中记录大量日志
for _, item := range items {
    logger.LogInfo("PROCESS", fmt.Sprintf("处理项目: %s", item.ID)) // 可能产生数千条日志
}

// 正确：记录汇总信息
logger.LogInfo("PROCESS", fmt.Sprintf("批量处理完成 - 共 %d 个项目", len(items)))
```

❌ **无意义的日志**
```go
// 错误：信息量不足
logger.LogInfo("CLICK", "按钮被点击")

// 正确：包含具体信息
logger.LogInfo("CLICK", "用户点击了保存配置按钮")
```

### 日志分析

#### 查看日志

```bash
# 查看最新日志
tail -f ~/Library/Logs/mole/mole_$(date +%Y-%m-%d).log

# 搜索特定模块的日志
grep "DATABASE" ~/Library/Logs/mole/mole_*.log

# 搜索错误日志
grep "ERROR" ~/Library/Logs/mole/mole_*.log

# 按时间范围查看
grep "2025-10-05 12:2" ~/Library/Logs/mole/mole_2025-10-05.log
```

#### 常见日志模式

1. **用户操作追踪**
```bash
grep "USER_ACTION.*click" mole.log
```

2. **性能问题分析**
```bash
grep "START.*ANALYSIS" mole.log
grep "ANALYSIS.*完成" mole.log
```

3. **错误排查**
```bash
grep -A5 -B5 "ERROR" mole.log
```

### 日志配置

#### 设置日志级别

```go
// 在 logger.go 中修改默认级别
globalLogger = &Logger{
    logLevel:   INFO,  // 改为 DEBUG 可查看更详细日志
    moduleName: "APP",
}
```

#### 禁用特定模块日志

```go
// 在不需要日志的模块中跳过
if os.Getenv("DISABLE_LOGS") == "true" {
    return // 跳过日志记录
}
```

### 最佳实践

1. **关键路径全覆盖**: 确保所有关键业务流程都有日志记录
2. **异常处理必记录**: 所有 try-catch 和错误处理都要有对应日志
3. **用户操作可追踪**: 重要用户行为都要记录，便于问题复现
4. **性能瓶颈可定位**: 关键操作的开始和结束时间要记录
5. **错误信息足够详细**: 错误日志要包含足够的上下文信息用于排查

## 调试技巧

### 1. 后端调试

#### 使用日志系统（推荐）
```go
// 使用内置日志系统替代 fmt.Printf
logger := GetLogger()
logger.SetModuleName("DEBUG")

logger.LogDebug("CONNECT", fmt.Sprintf("连接配置: %+v", config))
logger.LogInfo("TASK", fmt.Sprintf("分析任务启动: %s", task.ID))

// 条件日志记录
if os.Getenv("DEBUG") != "" {
    logger.LogDebug("DEBUG", fmt.Sprintf("任务状态: %s", task.Status))
}
```

#### 传统调试方式
```go
// 使用 fmt.Printf 调试（仅用于临时调试）
fmt.Printf("Connecting to database with config: %+v\n", config)

// 使用 log 包
log.Printf("Analysis task started: %s", task.ID)

// 条件编译调试
if os.Getenv("DEBUG") != "" {
    fmt.Printf("Debug: task status = %s\n", task.Status)
}
```

#### 调试级别设置
```go
// 在 logger.go 中临时启用 DEBUG 级别
globalLogger = &Logger{
    logLevel:   DEBUG,  // 临时启用详细日志
    moduleName: "APP",
}
```

### 2. 前端调试

#### 使用日志系统（推荐）
```typescript
import { createLogger } from "@/lib/logger";

// 创建调试专用日志记录器
const debugLogger = createLogger('DEBUG');

// 替代 console.log
debugLogger.info('状态变更', `当前步骤: ${currentStep}`);
debugLogger.debug('调试信息', `组件状态: ${JSON.stringify(state)}`);

// 条件调试
if (process.env.NODE_ENV === 'development') {
    debugLogger.info('开发调试', '开发环境专用日志');
}
```

#### 传统调试方式
```typescript
// 使用 console.log（仅用于快速调试）
console.log("Current step:", currentStep);

// 使用 React DevTools
// 安装 React Developer Tools 浏览器扩展

// 使用 Wails 开发者工具
// Wails dev 模式下有内置的开发者工具
```

#### 性能调试
```typescript
// 使用日志记录性能指标
const startTime = performance.now();
// ... 执行操作
const endTime = performance.now();
logger.info('PERFORMANCE', `操作耗时: ${endTime - startTime}ms`);
```

### 3. 问题排查流程

#### 使用日志系统排查
1. **查看最新日志**
   ```bash
   tail -f ~/Library/Logs/mole/mole_$(date +%Y-%m-%d).log
   ```

2. **按模块过滤**
   ```bash
   grep "DATABASE\|TASK_MANAGER" ~/Library/Logs/mole/mole_*.log
   ```

3. **错误追踪**
   ```bash
   grep -A10 -B5 "ERROR" ~/Library/Logs/mole/mole_*.log
   ```

4. **用户行为回放**
   ```bash
   grep "USER_ACTION.*click" ~/Library/Logs/mole/mole_*.log
   ```

## 性能优化

### 1. 后端优化
- 使用连接池管理数据库连接
- 实现查询结果缓存
- 优化 SQL 查询语句
- 合理设置并发数

### 2. 前端优化
- 使用 React.memo 避免不必要的重渲染
- 实现虚拟滚动处理大列表
- 使用防抖节流优化频繁操作
- 懒加载组件和资源

## 常见问题

### 1. 数据库连接问题
```go
// 确保正确关闭数据库连接
defer db.Close()

// 设置连接超时
db.SetConnMaxLifetime(time.Hour)
db.SetMaxOpenConns(10)
```

### 2. 前端状态管理
```typescript
// 使用 useCallback 避免函数重新创建
const handleSubmit = useCallback(async () => {
    // 提交逻辑
}, [dependencies]);

// 使用 useMemo 缓存计算结果
const expensiveValue = useMemo(() => {
    return computeExpensiveValue(data);
}, [data]);
```

### 3. 构建问题
```bash
# 清理构建缓存
wails build -clean

# 重新安装依赖
rm -rf node_modules package-lock.json
bun install

# 检查 Go 模块
go mod tidy
go mod download
```

## 贡献指南

1. **Fork 项目** 并创建功能分支
2. **编写代码** 并遵循代码规范
3. **添加测试** 确保功能正常
4. **更新文档** 包括 API 文档和用户文档
5. **提交 PR** 并描述变更内容

### 提交信息规范
```
feat: 添加新功能
fix: 修复问题
docs: 更新文档
style: 代码格式调整
refactor: 代码重构
test: 添加测试
chore: 构建工具或辅助工具的变动
```

这个开发指南为开发者提供了完整的开发环境搭建、代码规范、核心模块开发以及调试优化的指导，确保团队成员能够高效地参与项目开发。